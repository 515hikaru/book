---
sidebar_label: 型のメンタルモデル
---

# 型のメンタルモデル

## 型システムの背景理論

プログラミング言語の型システムにはそれぞれ固有の世界観があり、言語ごとにできること (型の機能) が異なります。

その一方で、共有している機能もあるわけで、それらのさまざまな型の機能は唐突にどこからともなく出現してきたわけではありません。背景として大きくは**型理論** (Type theory) と呼ばれる研究分野があり、各言語の型システムは型理論に基づいて実装されています。

たとえば、TypeScript の `unkown` 型や `never` 型のような一見何のためにある型かわからないようなものであっても、型理論においてはその役割や機能を一般的に説明することができます。これらの型は Top 型や Bottom 型と呼ばれる型の種類に分類され、部分型関係の端点に位置する型として振る舞います。

さらに型理論的な観点からの一般知識を持つことで似たような型システムを持つ他の言語においても型の機能について自然に推論することが可能になります。たとえば Scala という言語では `Any` 型と `Nothing` 型が `unknown` 型と `never` 型と同じ働きをすることが推論できます。一般化された型についての知識を使えるため、プログラミング言語をスイッチするような場合においてもスムーズに機能の類推や学習を行うことができるようになります。

ただし、型理論は非常に奥深く難解でもあるため、一般にはとっつきにくい分野です。その一方で、比較的簡単に理解できて実用的にも役立つ概念も非常に多くあります。このドキュメントではそういった知識から TypeScript の型の世界観、いわば**メンタルモデル**を構築するための知識を紹介します。

## 集合論的なデザイン

一般に型(type)は集合(set)は異なる概念ですが、型理論と集合論には密接な関連があります。

特に TypeScript においては、型を集合論的に扱えるようなデザインが意図的になされており、型を「**値の集合**」として捉えることで直感的に型を理解することができるようになっています。この見方は決して偏ったものではなく、[公式ドキュメントでも推奨されている](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-oop.html#types-as-sets)型の考え方です。

本章では、このような集合論的な見方に立って型を考えることで、型の振る舞いについての自然な推論を行えるようなメンタルモデルを構築します。

## 集合演算

型を集合論的に扱えるお陰で、TypeScript の型は集合が持つような演算の一部を利用することができます。

集合の演算は集合から新しい集合を作り出すような操作であり、そのような演算にはいくつも種類がありますが、TypeScript では和集合と共通部分を作り出すことができる演算が備わっています。

ユニオン型とインターセクション型はまさに和集合と共通部分を作る演算に相当します。

```ts twoslash title="型の和集合と共通部分"
type A = { fst: string };
type B = { snd: number };

type Union = A | B;
type Intersection = A & B;
```

直感的にはユニオン型はふたつの集合の和を表現する型であり、インターセクション型はふたつの型の共通部分を表現する型です。ユニオン型とインターセクション型をこのような集合論的な見方で扱うには次に紹介する３つの型が重要となります。

## ユニット型

ここからは、TypeScript において型は値の集合として扱えることができることを具体例を交えて説明していきます。

まずは単に型は値の集合であると考えてください。たとえば、`number` 型という数値を表す型ですが、この型が集合であるとするとその要素は具体的な `number` 型の値である数値です。たとえば `1` や `3.14` などの数値がこの集合の要素となります。次の章で述べたように `number` 型で表現可能な範囲は有限であり、それらの範囲の要素に `NaN` と `Infinity` などの特殊な定数を加えた集合が `number` 型の集合ということになります。

[number型の表現範囲](reference/values-types-variables/number)

さて、重要な型の概念として、型理論ではユニット型(Unit type)と呼ばれる型があります。ユニット型とはそのまま単位的(unit)な型であり、値をひとつしか持たないような型です。思い出してほしいのは、TypeScriptには[リテラル型](/values-types-variables/literal-types)という型がありました。TypeScript におけるユニット型はこのリテラル型などが相当します。

```ts twoslash title="リテラル型はユニット型"
type Unit = 1;
const one: Unit = 1;
```

リテラル型は値リテラルをそのまま型として表現できる型であり、`number` や `string` などのプリミティブ型にはそれぞれ具体的な値のリテラルによって作成されるリテラル型が存在します。

- 文字列リテラル型 : `"st"`, `"@"`, ...
- 数値リテラル型 : `1`, `3.14`, `-2`, ...
- 真偽値リテラル型 : `ture`, `false` のふたつのみ

型は値の集合でしたが、具体的な値はこのようにリテラルで表現でき、さらにそのリテラルを使ったリテラル型と一対一で対応します。

型は具体的な値の集合としてみなすことができました。リテラル型は具体的な値と一対一の他対応となるので、リテラル型を要素として集合を作ってみると考えてもよいでしょう。たとえば、真偽値のリテラル型は `ture` と `false` というふたつだけでした。このふたつはリテラル型なので値をひとつしかもたないユニット型です。型が集合だとするとユニット型も集合ですが、このような単一の要素のみからなる集合を単集合(singleton)と言います。というふたつの単集合`true` と `false` を合成してふたつの型(あるいは値)から和集合を作成するとよく知っている `boolean` の型を得ることができます。

```ts twoslash title="true と false の和集合"
type Bool = true | false;
```

このようにユニオン型で作成した型 `Bool` は `boolean` 型と同一です。

TypeScript には文字列や数値のリテラル型以外にもユニット型が存在しています。たとえば `undefined` と `null` という値はそれぞれ `undefined` 型と `null` 型に属しています。

```ts twoslash
type U = undefined;
const u: U = undefined;

type N = null;
const n: N = null;
```

逆に `undefiend` 型と `null` 型の要素はそれぞれ `undefined` と `null` しかありません。これらの型は集合としての要素をそれぞれひとつしか持っていないのでユニット型です。

## ボトム型

ユニット型が値をひとつしか持たない型なら、値をまったく持たない型も存在しています。そのような型をボトム型(Bottom type)と呼びます。型が集合であるとするとき、ボトム型は空集合(Empty set)に相当し、空型(Empty type)とも呼ばれることがあります。

ボトム型は値をまったく持たない型として、例外が発生する関数の返り値の型として利用されますが、TypeScriptでのボトム型はまさに `never`型です。

```ts twoslash
function neverReturn(): never {
  throw new Error("決して返ってこない関数");
}
```

`never` 型は集合としては空集合であり、値をひとつも持たないため、その型の変数にはどのような要素も割り当てることができません。

```ts twoslash
// @errors: 1206 2322
const n: never = 42;
```

## トップ型

ボトム型が値をまったく持たない型なら、すべての値を持つような型も存在しています。そのような型をトップ型(Top type)と呼びます。

トップ型はすべての値をもっており、その型の変数にはあらゆる値を割り当てることができます。オブジェクト指向言語であれば大抵は型階層のルート位置に存在している型であり、TypeScript では `unknown` 型がトップ型に相当します。

```ts twoslash
const u1: unknown = 42;
const u2: unknown = "st";
const u3: unknown = { p: 1 };
const u4: unknown = null;
const u5: unknown = () => 2;
```

ボトム型が空集合に相当するなら、トップ型は全体集合に相当すると言えるでしょう。

```ts twoslash
declare const u: unknown;
const t: {} | null | undefined = u;
```
